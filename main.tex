\documentclass[12pt,a4paper]{article}
\usepackage[margin=1in]{geometry}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{tcolorbox}

% Set up colors
\definecolor{darkblue}{rgb}{0, 0, 0.5}
\definecolor{darkgreen}{rgb}{0, 0.5, 0}
\definecolor{darkred}{rgb}{0.5, 0, 0}
\definecolor{codebackground}{rgb}{0.95, 0.95, 0.95}
\definecolor{codeborder}{rgb}{0.8, 0.8, 0.8}

% Code listing configuration
\lstset{
    language=java,
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{codebackground},
    numbers=left,
    numberstyle=\tiny\color{gray},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4,
    showspaces=false,
    showstringspaces=false,
    columns=fullflexible,
    frame=single,
    frameround=tttt,
    rulecolor=\color{codeborder},
    keywordstyle=\color{darkblue}\bfseries,
    commentstyle=\color{darkgreen},
    stringstyle=\color{darkred},
    captionpos=b
}

% Custom boxes
\newtcolorbox{importantbox}[1][]{%
    colback=blue!5!white,
    colframe=blue!75!black,
    fonttitle=\bfseries,
    title=Important,#1
}

\newtcolorbox{tipbox}[1][]{%
    colback=green!5!white,
    colframe=green!75!black,
    fonttitle=\bfseries,
    title=Tip,#1
}

\newtcolorbox{warningbox}[1][]{%
    colback=yellow!5!white,
    colframe=orange!75!black,
    fonttitle=\bfseries,
    title=Warning,#1
}

% Headers and footers
\pagestyle{fancy}
\fancyhf{}
\rhead{REST API Testing Lab}
\lhead{Unit \& Integration Testing}
\cfoot{\thepage}

\title{\Huge Comprehensive REST API Testing Lab \\
       \Large Unit, Integration, and Automated Testing \\
       \large with Spring Boot, MySQL, Mockito, and Postman}
\author{Student Lab Manual}
\date{Duration: 2-3 Hours \\ Target Audience: Students}

\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage

\section*{Lab Overview}

This comprehensive lab teaches professional testing practices for REST API development using Spring Boot. You will master three essential testing paradigms: unit testing to verify individual components in isolation, integration testing to validate database interactions, and automated API testing using Postman. Throughout this lab, you'll learn industry-standard practices including mocking external dependencies, managing test databases with Docker, and measuring code coverage with JaCoCo.

\textbf{Learning Outcomes:} By the end of this lab, you will be able to write production-grade tests, mock external services, verify database interactions, and automate API validationâ€”skills essential for any professional software engineer.

\newpage

\part{Part 1: Conceptual Foundation}

\section{Testing Pyramid and Test Types}

Professional software development follows the \textbf{testing pyramid}, a concept that defines the distribution and purpose of different test types.

\subsection{The Testing Pyramid}

\begin{center}
\begin{tabularx}{0.8\textwidth}{|l|X|X|}
\toprule
\textbf{Test Type} & \textbf{Characteristics} & \textbf{Purpose} \\
\midrule
\textbf{Unit Tests} (Base: 70\%) &
Fast, isolated, test single methods or functions. Mock all external dependencies. &
Verify individual component logic and catch bugs early. \\
\midrule
\textbf{Integration Tests} (Middle: 20\%) &
Slower, test multiple components together. Test with real or containerized databases. &
Verify that components work together correctly and database interactions are valid. \\
\midrule
\textbf{End-to-End Tests} (Top: 10\%) &
Slowest, test the entire application flow. Test from user perspective. &
Verify complete user workflows work as expected in production-like environments. \\
\bottomrule
\end{tabularx}
\end{center}

\subsection{Why Each Test Type Matters}

\subsubsection{Unit Tests}

Unit tests verify the \textbf{logic of individual components} in isolation. They should:

\begin{itemize}
    \item Execute in milliseconds (very fast feedback)
    \item Test a single \textbf{method or function} with multiple scenarios
    \item Mock all external dependencies (database, APIs, file systems)
    \item Be deterministic (always pass or always fail, never flaky)
\end{itemize}

\begin{tipbox}
Good unit tests are the first line of defense against bugs. They're fast enough to run hundreds of times during development, catching logic errors before they reach integration tests.
\end{tipbox}

\subsubsection{Integration Tests}

Integration tests verify that \textbf{multiple components work together}. They should:

\begin{itemize}
    \item Test real interactions (e.g., service + database)
    \item Use containerized or in-memory databases (not mocks)
    \item Execute in seconds (slower than unit tests, but still reasonably fast)
    \item Validate database queries, transaction handling, and data persistence
\end{itemize}

\begin{tipbox}
Integration tests catch issues that unit tests cannot find: incorrect SQL queries, missing database mappings, transactional bugs, and race conditions.
\end{tipbox}

\subsubsection{Automated API Tests (Postman)}

API tests verify that \textbf{endpoints respond correctly}. They should:

\begin{itemize}
    \item Test complete request-response cycles
    \item Validate HTTP status codes and response bodies
    \item Test edge cases and error scenarios
    \item Be automatable and repeatable
\end{itemize}

\section{Mocking and Test Isolation}

One of the most critical skills in testing is understanding \textbf{when and how to mock dependencies}.

\subsection{What is Mocking?}

A \textbf{mock} is a fake object that simulates the behavior of a real object. Instead of calling a real database or external API during a test, you use a mock that returns predetermined responses.

\subsection{Why Mock?}

\begin{description}
    \item[Speed] Real databases and APIs are slow. Mocks respond instantly.
    \item[Isolation] By mocking external services, you test only your code's logic, not the external service's behavior.
    \item[Reliability] External services might be unavailable or slow during testing. Mocks ensure consistent test behavior.
    \item[Cost] Mocking prevents charges from APIs with usage costs or rate limits.
\end{description}

\subsection{Mockito Framework}

\textbf{Mockito} is a Java mocking library that makes it easy to create mocks and verify interactions.

\begin{importantbox}
Key Mockito concepts:
\begin{itemize}
    \item \texttt{@Mock}: Creates a mock object (fake dependency)
    \item \texttt{@InjectMocks}: Injects mocks into the class being tested
    \item \texttt{when(...).thenReturn(...)}: Sets up what a mock should return
    \item \texttt{verify()}: Asserts that a mock method was called
\end{itemize}
\end{importantbox}

\section{Database Testing Strategies}

\subsection{In-Memory vs. Docker vs. TestContainers}

\begin{table}[H]
\centering
\small
\begin{tabularx}{\textwidth}{|l|X|X|X|}
\toprule
\textbf{Approach} & \textbf{Setup} & \textbf{Realism} & \textbf{Speed} \\
\midrule
\textbf{H2 In-Memory} &
Very fast, no setup. &
Low; doesn't match production MySQL. &
Very fast. \\
\midrule
\textbf{Docker Compose} &
Requires Docker installed. &
High; real MySQL instance. &
Fast; startup takes seconds. \\
\midrule
\textbf{TestContainers} &
Requires Docker; automatic provisioning. &
High; spins up a real database. &
Fast; container lifecycle automated. \\
\bottomrule
\end{tabularx}
\end{table}

\textbf{For this lab}, we'll use \textbf{Docker Compose} to spin up a real MySQL database specifically for testing.

\subsection{Test Profile Configuration}

Spring Boot supports multiple profiles (dev, test, prod). We'll create a \texttt{test} profile so tests use their own MySQL database, separate from development.

\newpage

\part{Part 2: Environment Setup}

\section{Step 1: Prerequisites and Installation}

\subsection{Required Software}

Before starting, ensure you have installed:

\begin{itemize}
    \item \textbf{Java Development Kit (JDK) 17+} - \url{https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html}
    \item \textbf{IntelliJ IDEA Community Edition} - \url{https://www.jetbrains.com/idea/download/}
    \item \textbf{Docker Desktop} - \url{https://www.docker.com/products/docker-desktop/}
    \item \textbf{Postman} - \url{https://www.postman.com/downloads/}
    \item \textbf{MySQL Workbench (optional)} - \url{https://dev.mysql.com/downloads/workbench/}
\end{itemize}

\subsection{Verify Installation}

\begin{lstlisting}[language=bash, caption=Verify all tools are installed]
# Check Java
java -version

# Check Docker
docker --version
docker-compose --version

# Verify Docker daemon is running
docker ps
\end{lstlisting}

\section{Step 2: Project Setup}

\subsection{Option A: Download Starter Project}

\begin{itemize}
    \item Visit: \url{https://github.com/Braniacsl/CS4297-Lab}
    \item Click the green "Code" button and select "Download ZIP"
    \item Extract the ZIP file
    \item Open the project in IntelliJ IDEA
\end{itemize}

\subsection{Option B: Create from Scratch}

Use Spring Initializr (\url{https://start.spring.io/}) with these dependencies:

\begin{itemize}
    \item Spring Web
    \item Spring Data JPA
    \item MySQL Driver
    \item JUnit Jupiter (for testing)
    \item Mockito (for mocking)
\end{itemize}

\section{Step 3: Configure Docker Compose for Testing}

Create a \texttt{docker-compose.yml} file in your project root:

\begin{lstlisting}[language=bash, caption=docker-compose.yml - MySQL Database Setup]
version: '3.8'
services:
  mysql-test:
    image: mysql:8.0
    container_name: mysql-test-db
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: rootpass
      MYSQL_DATABASE: testdb
      MYSQL_USER: testuser
      MYSQL_PASSWORD: testpass
    ports:
      - "3306:3306"
    volumes:
      - mysql-test-data:/var/lib/mysql
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      timeout: 5s
      retries: 10

volumes:
  mysql-test-data:
\end{lstlisting}

\subsection{Database Initialization Script}

Create \texttt{init.sql} in your project root:

\begin{lstlisting}[language=sql, caption=init.sql - Database Schema]
-- Create Users table
CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(100) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- Create sample index for performance
CREATE INDEX idx_email ON users(email);
\end{lstlisting}

\subsection{Start the Test Database}

\begin{lstlisting}[language=bash, caption=Start Docker Compose]
# From your project root directory
docker-compose up -d

# Verify the container is running
docker ps

# Verify you can connect to MySQL
docker exec mysql-test-db mysql -u testuser -ptestpass testdb -e "SELECT 1;"
\end{lstlisting}

\begin{tipbox}
The \texttt{-d} flag starts the container in detached mode (runs in background). Use \texttt{docker-compose logs -f} to view logs, and \texttt{docker-compose down} to stop when finished.
\end{tipbox}

\section{Step 4: Configure Spring Boot Application Properties}

Create \texttt{src/main/resources/application-test.properties}:

\begin{lstlisting}[language=bash, caption=application-test.properties - Test Profile Configuration]
# Database Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/testdb
spring.datasource.username=testuser
spring.datasource.password=testpass
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# Hibernate Configuration
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.format_sql=true

# Logging
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# Server Port for Integration Tests
server.port=8081
\end{lstlisting}

\newpage

\part{Part 3: Unit Testing}

\section{Step 1: Build Service Layer with Dependencies}

\subsection{Create User Entity}

\begin{lstlisting}[language=java, caption=User.java - JPA Entity]
package com.cs4297.lab.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String username;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}
\end{lstlisting}

\subsection{Create Repository Interface}

\begin{lstlisting}[language=java, caption=UserRepository.java - Spring Data JPA Repository]
package com.cs4297.lab.repository;

import com.cs4297.lab.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    Optional<User> findByUsername(String username);
    boolean existsByEmail(String email);
    boolean existsByUsername(String username);
}
\end{lstlisting}

\subsection{Create Service Class}

\begin{lstlisting}[language=java, caption=UserService.java - Business Logic Layer]
package com.cs4297.lab.service;

import com.cs4297.lab.model.User;
import com.cs4297.lab.repository.UserRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.Optional;
import java.util.regex.Pattern;

@Service
@Transactional
public class UserService {

    private final UserRepository userRepository;
    private static final String EMAIL_REGEX =
        "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}$";
    private static final Pattern EMAIL_PATTERN =
        Pattern.compile(EMAIL_REGEX);

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public User createUser(String username, String email, String password) {
        // Validate inputs
        if (!isValidEmail(email)) {
            throw new IllegalArgumentException("Invalid email format");
        }

        if (userRepository.existsByEmail(email)) {
            throw new IllegalArgumentException("Email already exists");
        }

        if (userRepository.existsByUsername(username)) {
            throw new IllegalArgumentException("Username already exists");
        }

        if (password == null || password.length() < 8) {
            throw new IllegalArgumentException(
                "Password must be at least 8 characters");
        }

        User user = new User();
        user.setUsername(username);
        user.setEmail(email);
        user.setPassword(password); // In production, hash this!

        return userRepository.save(user);
    }

    public Optional<User> getUserById(Long id) {
        return userRepository.findById(id);
    }

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    public Optional<User> updateUser(Long id, String email, String password) {
        return userRepository.findById(id).map(user -> {
            if (email != null && !email.equals(user.getEmail())) {
                if (!isValidEmail(email)) {
                    throw new IllegalArgumentException("Invalid email");
                }
                user.setEmail(email);
            }
            if (password != null && password.length() >= 8) {
                user.setPassword(password);
            }
            return userRepository.save(user);
        });
    }

    public boolean deleteUser(Long id) {
        if (userRepository.existsById(id)) {
            userRepository.deleteById(id);
            return true;
        }
        return false;
    }

    private boolean isValidEmail(String email) {
        return email != null && EMAIL_PATTERN.matcher(email).matches();
    }
}
\end{lstlisting}

\section{Step 2: Write Unit Tests for Service}

\begin{lstlisting}[language=java, caption=UserServiceTest.java - Unit Tests with Mockito]
package com.cs4297.lab.service;

import com.cs4297.lab.model.User;
import com.cs4297.lab.repository.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @InjectMocks
    private UserService userService;

    private User testUser;

    @BeforeEach
    void setUp() {
        testUser = new User();
        testUser.setId(1L);
        testUser.setUsername("testuser");
        testUser.setEmail("test@example.com");
        testUser.setPassword("password123");
    }

    @Test
    void testCreateUser_Success() {
        // Arrange
        when(userRepository.existsByEmail("test@example.com"))
            .thenReturn(false);
        when(userRepository.existsByUsername("testuser"))
            .thenReturn(false);
        when(userRepository.save(any(User.class)))
            .thenReturn(testUser);

        // Act
        User created = userService.createUser(
            "testuser", "test@example.com", "password123");

        // Assert
        assertNotNull(created);
        assertEquals("testuser", created.getUsername());
        assertEquals("test@example.com", created.getEmail());
        verify(userRepository, times(1)).save(any(User.class));
    }

    @Test
    void testCreateUser_InvalidEmail() {
        // Act & Assert
        assertThrows(IllegalArgumentException.class, () ->
            userService.createUser("testuser", "invalid-email",
                "password123")
        );

        // Verify save was never called
        verify(userRepository, never()).save(any());
    }

    @Test
    void testCreateUser_DuplicateEmail() {
        // Arrange
        when(userRepository.existsByEmail("test@example.com"))
            .thenReturn(true);

        // Act & Assert
        assertThrows(IllegalArgumentException.class, () ->
            userService.createUser("testuser", "test@example.com",
                "password123")
        );

        verify(userRepository, never()).save(any());
    }

    @Test
    void testCreateUser_WeakPassword() {
        // Act & Assert
        assertThrows(IllegalArgumentException.class, () ->
            userService.createUser("testuser", "test@example.com",
                "weak")
        );

        verify(userRepository, never()).save(any());
    }

    @Test
    void testGetUserById_Found() {
        // Arrange
        when(userRepository.findById(1L))
            .thenReturn(Optional.of(testUser));

        // Act
        Optional<User> found = userService.getUserById(1L);

        // Assert
        assertTrue(found.isPresent());
        assertEquals("testuser", found.get().getUsername());
    }

    @Test
    void testGetUserById_NotFound() {
        // Arrange
        when(userRepository.findById(99L))
            .thenReturn(Optional.empty());

        // Act
        Optional<User> found = userService.getUserById(99L);

        // Assert
        assertFalse(found.isPresent());
    }

    @Test
    void testDeleteUser_Success() {
        // Arrange
        when(userRepository.existsById(1L)).thenReturn(true);

        // Act
        boolean deleted = userService.deleteUser(1L);

        // Assert
        assertTrue(deleted);
        verify(userRepository, times(1)).deleteById(1L);
    }

    @Test
    void testDeleteUser_NotFound() {
        // Arrange
        when(userRepository.existsById(99L)).thenReturn(false);

        // Act
        boolean deleted = userService.deleteUser(99L);

        // Assert
        assertFalse(deleted);
        verify(userRepository, never()).deleteById(any());
    }
}
\end{lstlisting}

\begin{importantbox}
Notice the pattern in these tests:
\begin{itemize}
    \item \textbf{Arrange}: Set up mocks with \texttt{when(...).thenReturn(...)}
    \item \textbf{Act}: Call the method being tested
    \item \textbf{Assert}: Verify the results with assertions
    \item \textbf{Verify}: Check that mocks were called correctly
\end{itemize}
\end{importantbox}

\newpage

\part{Part 4: Controller Testing with MockMvc}

\section{Step 1: Create REST Controller}

\begin{lstlisting}[language=java, caption=UserController.java - REST API Endpoints]
package com.cs4297.lab.controller;

import com.cs4297.lab.model.User;
import com.cs4297.lab.service.UserService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping
    public ResponseEntity<List<User>> getAllUsers() {
        List<User> users = userService.getAllUsers();
        return ResponseEntity.ok(users);
    }

    @GetMapping("/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        return userService.getUserById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    public ResponseEntity<User> createUser(
            @RequestParam String username,
            @RequestParam String email,
            @RequestParam String password) {
        try {
            User user = userService.createUser(username, email, password);
            return ResponseEntity.status(HttpStatus.CREATED).body(user);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().build();
        }
    }

    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(
            @PathVariable Long id,
            @RequestParam(required = false) String email,
            @RequestParam(required = false) String password) {
        try {
            return userService.updateUser(id, email, password)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().build();
        }
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        if (userService.deleteUser(id)) {
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.notFound().build();
    }
}
\end{lstlisting}

\section{Step 2: Test Controller with MockMvc}

\begin{lstlisting}[language=java, caption=UserControllerTest.java - Controller Layer Tests]
package com.cs4297.lab.controller;

import com.cs4297.lab.model.User;
import com.cs4297.lab.service.UserService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import java.util.Arrays;
import java.util.Optional;

import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
import static org.hamcrest.Matchers.is;

@WebMvcTest(UserController.class)
class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService userService;

    private User user1;
    private User user2;

    @BeforeEach
    void setUp() {
        user1 = new User();
        user1.setId(1L);
        user1.setUsername("alice");
        user1.setEmail("alice@example.com");
        user1.setPassword("password123");

        user2 = new User();
        user2.setId(2L);
        user2.setUsername("bob");
        user2.setEmail("bob@example.com");
        user2.setPassword("password456");
    }

    @Test
    void testGetAllUsers_Success() throws Exception {
        // Arrange
        when(userService.getAllUsers())
            .thenReturn(Arrays.asList(user1, user2));

        // Act & Assert
        mockMvc.perform(get("/api/users")
                .contentType(MediaType.APPLICATION_JSON))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.length()", is(2)))
            .andExpect(jsonPath("$[0].username", is("alice")))
            .andExpect(jsonPath("$[1].username", is("bob")));
    }

    @Test
    void testGetUserById_Success() throws Exception {
        // Arrange
        when(userService.getUserById(1L))
            .thenReturn(Optional.of(user1));

        // Act & Assert
        mockMvc.perform(get("/api/users/1")
                .contentType(MediaType.APPLICATION_JSON))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.username", is("alice")))
            .andExpect(jsonPath("$.email", is("alice@example.com")));
    }

    @Test
    void testGetUserById_NotFound() throws Exception {
        // Arrange
        when(userService.getUserById(99L))
            .thenReturn(Optional.empty());

        // Act & Assert
        mockMvc.perform(get("/api/users/99")
                .contentType(MediaType.APPLICATION_JSON))
            .andExpect(status().isNotFound());
    }

    @Test
    void testCreateUser_Success() throws Exception {
        // Arrange
        when(userService.createUser("alice", "alice@example.com",
            "password123"))
            .thenReturn(user1);

        // Act & Assert
        mockMvc.perform(post("/api/users")
                .param("username", "alice")
                .param("email", "alice@example.com")
                .param("password", "password123")
                .contentType(MediaType.APPLICATION_JSON))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.username", is("alice")));
    }

    @Test
    void testCreateUser_InvalidEmail() throws Exception {
        // Arrange
        when(userService.createUser("alice", "invalid", "password123"))
            .thenThrow(new IllegalArgumentException("Invalid email"));

        // Act & Assert
        mockMvc.perform(post("/api/users")
                .param("username", "alice")
                .param("email", "invalid")
                .param("password", "password123")
                .contentType(MediaType.APPLICATION_JSON))
            .andExpect(status().isBadRequest());
    }

    @Test
    void testDeleteUser_Success() throws Exception {
        // Arrange
        when(userService.deleteUser(1L)).thenReturn(true);

        // Act & Assert
        mockMvc.perform(delete("/api/users/1")
                .contentType(MediaType.APPLICATION_JSON))
            .andExpect(status().isNoContent());
    }

    @Test
    void testDeleteUser_NotFound() throws Exception {
        // Arrange
        when(userService.deleteUser(99L)).thenReturn(false);

        // Act & Assert
        mockMvc.perform(delete("/api/users/99")
                .contentType(MediaType.APPLICATION_JSON))
            .andExpect(status().isNotFound());
    }
}
\end{lstlisting}

\begin{tipbox}
\texttt{@WebMvcTest} creates a lightweight Spring context with only MVC components, making tests fast and focused. \texttt{MockMvc} simulates HTTP requests without starting a real server.
\end{tipbox}

\newpage

\part{Part 5: Integration Testing with Real Database}

\section{Step 1: Repository Integration Tests}

\begin{lstlisting}[language=java, caption=UserRepositoryTest.java - Database Integration Tests]
package com.cs4297.lab.repository;

import com.cs4297.lab.model.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.test.context.TestPropertySource;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;

@DataJpaTest
@TestPropertySource(locations = "classpath:application-test.properties")
class UserRepositoryTest {

    @Autowired
    private UserRepository userRepository;

    private User testUser;

    @BeforeEach
    void setUp() {
        testUser = new User();
        testUser.setUsername("testuser");
        testUser.setEmail("test@example.com");
        testUser.setPassword("password123");
    }

    @Test
    void testSaveUser() {
        // Act
        User saved = userRepository.save(testUser);

        // Assert
        assertNotNull(saved.getId());
        assertEquals("testuser", saved.getUsername());
    }

    @Test
    void testFindByEmail() {
        // Arrange
        userRepository.save(testUser);

        // Act
        Optional<User> found = userRepository.findByEmail("test@example.com");

        // Assert
        assertTrue(found.isPresent());
        assertEquals("testuser", found.get().getUsername());
    }

    @Test
    void testFindByUsername() {
        // Arrange
        userRepository.save(testUser);

        // Act
        Optional<User> found = userRepository.findByUsername("testuser");

        // Assert
        assertTrue(found.isPresent());
        assertEquals("test@example.com", found.get().getEmail());
    }

    @Test
    void testExistsByEmail_True() {
        // Arrange
        userRepository.save(testUser);

        // Act
        boolean exists = userRepository.existsByEmail("test@example.com");

        // Assert
        assertTrue(exists);
    }

    @Test
    void testExistsByEmail_False() {
        // Act
        boolean exists = userRepository.existsByEmail("nonexistent@example.com");

        // Assert
        assertFalse(exists);
    }

    @Test
    void testUpdateUser() {
        // Arrange
        User saved = userRepository.save(testUser);
        Long userId = saved.getId();

        // Act
        saved.setEmail("newemail@example.com");
        userRepository.save(saved);
        Optional<User> updated = userRepository.findById(userId);

        // Assert
        assertTrue(updated.isPresent());
        assertEquals("newemail@example.com", updated.get().getEmail());
    }

    @Test
    void testDeleteUser() {
        // Arrange
        User saved = userRepository.save(testUser);
        Long userId = saved.getId();

        // Act
        userRepository.deleteById(userId);
        Optional<User> deleted = userRepository.findById(userId);

        // Assert
        assertFalse(deleted.isPresent());
    }
}
\end{lstlisting}

\begin{tipbox}
\texttt{@DataJpaTest} automatically configures a test database and enables transaction management. Each test runs in a transaction that's rolled back afterward, keeping tests isolated.
\end{tipbox}

\section{Step 2: Full Stack Integration Tests}

\begin{lstlisting}[language=java, caption=UserControllerIntegrationTest.java - Full Stack Tests]
package com.cs4297.lab;

import com.cs4297.lab.model.User;
import com.cs4297.lab.repository.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
import static org.hamcrest.Matchers.is;

@SpringBootTest
@AutoConfigureMockMvc
@TestPropertySource(locations = "classpath:application-test.properties")
class UserControllerIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private UserRepository userRepository;

    @BeforeEach
    void setUp() {
        // Clean up database before each test
        userRepository.deleteAll();
    }

    @Test
    void testCreateAndRetrieveUser() throws Exception {
        // Create user
        mockMvc.perform(post("/api/users")
                .param("username", "alice")
                .param("email", "alice@example.com")
                .param("password", "password123"))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.username", is("alice")));

        // Retrieve all users
        mockMvc.perform(get("/api/users"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.length()", is(1)))
            .andExpect(jsonPath("$[0].email", is("alice@example.com")));
    }

    @Test
    void testUpdateUserThroughAPI() throws Exception {
        // Create user
        mockMvc.perform(post("/api/users")
                .param("username", "alice")
                .param("email", "alice@example.com")
                .param("password", "password123"))
            .andExpect(status().isCreated());

        // Get the user ID from database
        User user = userRepository.findByUsername("alice").orElse(null);
        assert user != null;

        // Update user
        mockMvc.perform(put("/api/users/" + user.getId())
                .param("email", "newemail@example.com"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.email", is("newemail@example.com")));
    }

    @Test
    void testCreateDuplicateUser() throws Exception {
        // Create first user
        mockMvc.perform(post("/api/users")
                .param("username", "alice")
                .param("email", "alice@example.com")
                .param("password", "password123"))
            .andExpect(status().isCreated());

        // Try to create duplicate
        mockMvc.perform(post("/api/users")
                .param("username", "alice2")
                .param("email", "alice@example.com")
                .param("password", "password123"))
            .andExpect(status().isBadRequest());
    }
}
\end{lstlisting}

\newpage

\part{Part 6: Automated API Testing with Postman}

\section{Step 1: Start Your Application}

\begin{lstlisting}[language=bash, caption=Start Spring Boot Application]
# From IntelliJ IDE:
# 1. Right-click on the main application class
# 2. Select "Run 'Application'" or press Ctrl+Shift+F10

# Or from command line:
./mvnw spring-boot:run
\end{lstlisting}

\section{Step 2: Create Postman Collection}

\begin{enumerate}
    \item Open Postman
    \item Click "Create" â†’ "Collection"
    \item Name it "User API Tests"
    \item Click "Create"
\end{enumerate}

\section{Step 3: Add Environment Variable}

\begin{enumerate}
    \item Click "Environments" in the left sidebar
    \item Click "Create Environment"
    \item Name it "Test"
    \item Add variable:
    \begin{itemize}
        \item \textbf{Key:} \texttt{baseUrl}
        \item \textbf{Value:} \texttt{http://localhost:8080}
    \end{itemize}
    \item Click "Save"
    \item Select "Test" environment in the dropdown
\end{enumerate}

\section{Step 4: Create Test Requests}

\subsection{GET All Users}

\begin{enumerate}
    \item Add request to collection: \textbf{GET} \texttt{\{\{baseUrl\}\}/api/users}
    \item Go to "Tests" tab
    \item Add test script:
\end{enumerate}

\begin{lstlisting}[caption=Postman Test - GET All Users]
pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});

pm.test("Response is an array", function () {
    pm.expect(pm.response.json()).to.be.an('array');
});

pm.test("Response time is less than 1000ms", function () {
    pm.expect(pm.response.responseTime).to.be.below(1000);
});
\end{lstlisting}

\subsection{Create User (POST)}

\begin{enumerate}
    \item Add request: \textbf{POST} \texttt{\{\{baseUrl\}\}/api/users}
    \item Body (form-data):
    \begin{itemize}
        \item \texttt{username}: \texttt{alice}
        \item \texttt{email}: \texttt{alice@example.com}
        \item \texttt{password}: \texttt{password123}
    \end{itemize}
    \item Tests tab:
\end{enumerate}

\begin{lstlisting}[caption=Postman Test - Create User]
pm.test("Status code is 201", function () {
    pm.response.to.have.status(201);
});

pm.test("User ID is returned", function () {
    var jsonData = pm.response.json();
    pm.expect(jsonData).to.have.property("id");
    pm.expect(jsonData.id).to.be.above(0);
});

pm.test("Email is correct", function () {
    var jsonData = pm.response.json();
    pm.expect(jsonData.email).to.equal("alice@example.com");
});

// Save user ID for next requests
pm.environment.set("userId", pm.response.json().id);
\end{lstlisting}

\subsection{Get User by ID}

\begin{enumerate}
    \item Add request: \textbf{GET} \texttt{\{\{baseUrl\}\}/api/users/\{\{userId\}\}}
    \item Tests tab:
\end{enumerate}

\begin{lstlisting}[caption=Postman Test - Get User by ID]
pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});

pm.test("Correct user is returned", function () {
    var jsonData = pm.response.json();
    pm.expect(jsonData.username).to.equal("alice");
});
\end{lstlisting}

\subsection{Update User (PUT)}

\begin{enumerate}
    \item Add request: \textbf{PUT} \texttt{\{\{baseUrl\}\}/api/users/\{\{userId\}\}}
    \item Body (form-data):
    \begin{itemize}
        \item \texttt{email}: \texttt{newemail@example.com}
    \end{itemize}
    \item Tests tab:
\end{enumerate}

\begin{lstlisting}[caption=Postman Test - Update User]
pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});

pm.test("Email was updated", function () {
    var jsonData = pm.response.json();
    pm.expect(jsonData.email).to.equal("newemail@example.com");
});
\end{lstlisting}

\subsection{Delete User}

\begin{enumerate}
    \item Add request: \textbf{DELETE} \texttt{\{\{baseUrl\}\}/api/users/\{\{userId\}\}}
    \item Tests tab:
\end{enumerate}

\begin{lstlisting}[caption=Postman Test - Delete User]
pm.test("Status code is 204", function () {
    pm.response.to.have.status(204);
});

// Clear the userId variable after successful delete
pm.environment.unset("userId");
\end{lstlisting}

\section{Step 5: Run Collection with Runner}

\begin{enumerate}
    \item Click "Runner" in top menu
    \item Select your "User API Tests" collection
    \item Select "Test" environment
    \item Click "Run User API Tests"
    \item Observe all tests passing (green checkmarks)
\end{enumerate}

\begin{tipbox}
The runner executes all requests in order. Notice how the POST request saves the user ID, and subsequent requests use that ID. This demonstrates data flow between requests.
\end{tipbox}

\newpage

\part{Part 7: Code Coverage Analysis with JaCoCo}

\section{Step 1: Add JaCoCo Plugin to POM}

Add to \texttt{pom.xml}:

\begin{lstlisting}[language=xml, caption=pom.xml - JaCoCo Configuration]
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.8</version>
    <executions>
        <execution>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>report</id>
            <phase>test</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
    </executions>
</plugin>
\end{lstlisting}

\section{Step 2: Run Tests with Coverage}

\begin{lstlisting}[language=bash, caption=Generate Coverage Report]
# Run Maven tests and generate JaCoCo report
./mvnw clean test

# Open the HTML report
# Location: target/site/jacoco/index.html
open target/site/jacoco/index.html
\end{lstlisting}

\section{Step 3: Interpret Coverage Report}

The JaCoCo report shows four metrics:

\begin{description}
    \item[Line Coverage] Percentage of executable code lines executed by tests
    \item[Branch Coverage] Percentage of code branches (if/else) tested
    \item[Cyclomatic Complexity] Number of different paths through code
    \item[Method Coverage] Percentage of methods tested
\end{description}

\begin{importantbox}
Industry standard target: \textbf{80\% code coverage}. Aim for high coverage on business logic; lower coverage on generated code is acceptable.
\end{importantbox}

\newpage

\part{Part 8: Advanced Testing Scenarios}

\section{Mocking External API Calls}

When your service calls an external API, mock it in tests to avoid:
\begin{itemize}
    \item Network latency
    \item External service unavailability
    \item API rate limits
    \item Unexpected responses
\end{itemize}

\subsection{Example: Payment API Integration}

\begin{lstlisting}[language=java, caption=PaymentService with External API Call]
package com.cs4297.lab.service;

public interface PaymentClient {
    PaymentResponse processPayment(String userId, double amount);
}

public class PaymentService {
    private final PaymentClient paymentClient;

    public PaymentService(PaymentClient paymentClient) {
        this.paymentClient = paymentClient;
    }

    public String chargeUser(String userId, double amount) {
        try {
            PaymentResponse response = paymentClient.processPayment(
                userId, amount);
            if (response.isSuccessful()) {
                return "Payment of $" + amount + " successful. " +
                    "Transaction ID: " + response.getTransactionId();
            }
        } catch (PaymentException e) {
            return "Payment failed: " + e.getMessage();
        }
        return "Payment failed: unknown error";
    }
}
\end{lstlisting}

\subsection{Unit Tests with Mocked API}

\begin{lstlisting}[language=java, caption=PaymentServiceTest - Testing with Mock API]
@ExtendWith(MockitoExtension.class)
class PaymentServiceTest {

    @Mock
    private PaymentClient paymentClient;

    @InjectMocks
    private PaymentService paymentService;

    @Test
    void testChargeUser_Success() {
        // Arrange
        PaymentResponse mockResponse = new PaymentResponse(true, "TXN123");
        when(paymentClient.processPayment("user1", 100.0))
            .thenReturn(mockResponse);

        // Act
        String result = paymentService.chargeUser("user1", 100.0);

        // Assert
        assertTrue(result.contains("successful"));
        assertTrue(result.contains("TXN123"));
    }

    @Test
    void testChargeUser_PaymentFailure() {
        // Arrange
        PaymentResponse mockResponse = new PaymentResponse(false, null);
        when(paymentClient.processPayment("user1", 100.0))
            .thenReturn(mockResponse);

        // Act
        String result = paymentService.chargeUser("user1", 100.0);

        // Assert
        assertTrue(result.contains("failed"));
    }

    @Test
    void testChargeUser_ExceptionHandling() {
        // Arrange
        when(paymentClient.processPayment("user1", 100.0))
            .thenThrow(new PaymentException("Network timeout"));

        // Act
        String result = paymentService.chargeUser("user1", 100.0);

        // Assert
        assertTrue(result.contains("Payment failed"));
    }
}
\end{lstlisting}

\newpage

\part{Part 9: Lab Demonstration and Evaluation}

\section{What Students Must Demonstrate}

\begin{table}[H]
\centering
\small
\begin{tabularx}{\textwidth}{|l|X|X|}
\toprule
\textbf{Component} & \textbf{Evidence} & \textbf{Evaluation Focus} \\
\midrule
\textbf{Unit Tests} &
All unit tests pass. Show test output. Explain what each test verifies. &
Understanding of test isolation and mocking. \\
\midrule
\textbf{Integration Tests} &
Integration tests run against real database. Show \texttt{@DataJpaTest} and \texttt{@SpringBootTest} tests passing. &
Database interaction and transaction handling. \\
\midrule
\textbf{Controller Tests} &
MockMvc tests pass. Show JSON response validation. &
HTTP request/response testing. \\
\midrule
\textbf{Postman Collection} &
Run entire collection in Postman runner. All tests green. Show variable persistence across requests. &
Automated API testing workflow. \\
\midrule
\textbf{Code Coverage} &
Show JaCoCo report. Explain line/branch coverage. Target 80\%+ on service layer. &
Understanding testing metrics and coverage goals. \\
\bottomrule
\end{tabularx}
\end{table}

\section{Sample Interview Questions}

\begin{enumerate}
    \item \textbf{Q: Why should you mock external dependencies in unit tests?}

    \textit{A:} Mocks isolate the code being tested, make tests faster, and prevent failures due to external service unavailability. They allow testing edge cases without relying on real services.

    \item \textbf{Q: What's the difference between \texttt{@WebMvcTest} and \texttt{@SpringBootTest}?}

    \textit{A:} \texttt{@WebMvcTest} creates a lightweight context with only MVC components. \texttt{@SpringBootTest} loads the full application context including database. WebMvcTest is faster; SpringBootTest is more realistic.

    \item \textbf{Q: When should you use integration tests vs. unit tests?}

    \textit{A:} Unit tests verify individual component logic (faster, more isolated). Integration tests verify components work together (slower, more realistic). Use both: mostly unit tests, some integration tests.

    \item \textbf{Q: How does Mockito's \texttt{@InjectMocks} work?}

    \textit{A:} It creates an instance of the class under test and injects all \texttt{@Mock} fields into it. This eliminates boilerplate constructor code.

    \item \textbf{Q: What does 80\% code coverage mean?}

    \textit{A:} 80\% of the executable code lines are executed by tests. However, coverage doesn't guarantee correctnessâ€”tests must verify correct behavior, not just execute code.
\end{enumerate}

\newpage

\appendix

\section{Troubleshooting Guide}

\subsection{Docker Issues}

\subsubsection{Error: "Cannot connect to Docker daemon"}

\begin{warningbox}
\textbf{Solution:}
\begin{enumerate}
    \item Ensure Docker Desktop is running (check system tray)
    \item On Mac/Linux: \texttt{docker --version} should work
    \item Restart Docker Desktop
\end{enumerate}
\end{warningbox}

\subsubsection{Error: "Port 3306 already in use"}

\begin{warningbox}
\textbf{Solution:}
\begin{enumerate}
    \item Check what's using the port: \texttt{lsof -i :3306}
    \item Stop the container: \texttt{docker-compose down}
    \item Or use different port in docker-compose.yml: \texttt{- "3307:3306"}
\end{enumerate}
\end{warningbox}

\subsection{Test Failures}

\subsubsection{Error: "NullPointerException on @Mock field"}

\begin{warningbox}
\textbf{Solution:}
\begin{enumerate}
    \item Verify \texttt{@ExtendWith(MockitoExtension.class)} is present on test class
    \item Ensure \texttt{@InjectMocks} is on the class under test, not \texttt{@Autowired}
\end{enumerate}
\end{warningbox}

\subsubsection{Error: "Cannot find test database"}

\begin{warningbox}
\textbf{Solution:}
\begin{enumerate}
    \item Verify \texttt{application-test.properties} exists in \texttt{src/test/resources/}
    \item Verify docker-compose is running: \texttt{docker ps}
    \item Check database connection URL matches your setup
\end{enumerate}
\end{warningbox}

\subsection{Postman Issues}

\subsubsection{Problem: Environment variable not persisting between requests}

\begin{warningbox}
\textbf{Solution:}
\begin{enumerate}
    \item Use \texttt{pm.environment.set("key", value);} in test script
    \item Verify you've selected the correct environment
    \item Check the environment dropdown shows your environment name
\end{enumerate}
\end{warningbox}

\section{Best Practices Summary}

\begin{itemize}
    \item \textbf{Test pyramid:} 70\% unit, 20\% integration, 10\% end-to-end
    \item \textbf{Isolation:} Mock external dependencies in unit tests
    \item \textbf{Realistic:} Use real databases in integration tests
    \item \textbf{Coverage:} Target 80\% code coverage on business logic
    \item \textbf{Naming:} Use clear test names like \texttt{testCreateUser\_Success}
    \item \textbf{Organization:} Group related tests with \texttt{@Nested} classes
    \item \textbf{Cleanup:} Always clean up test data in \texttt{@BeforeEach} or \texttt{@AfterEach}
\end{itemize}

\section{Quick Reference: Testing Annotations}

\begin{table}[H]
\centering
\small
\begin{tabularx}{\textwidth}{|l|X|}
\toprule
\textbf{Annotation} & \textbf{Purpose} \\
\midrule
\texttt{@Test} & Marks method as a test case \\
\texttt{@BeforeEach} & Runs before each test (setup) \\
\texttt{@AfterEach} & Runs after each test (cleanup) \\
\texttt{@Mock} & Creates a mock object \\
\texttt{@InjectMocks} & Injects mocks into class under test \\
\texttt{@ExtendWith(MockitoExtension.class)} & Enables Mockito in test class \\
\texttt{@WebMvcTest} & Tests MVC layer only (lightweight) \\
\texttt{@SpringBootTest} & Tests entire application (full context) \\
\texttt{@DataJpaTest} & Tests JPA repositories with database \\
\texttt{@TestPropertySource} & Provides test-specific properties \\
\bottomrule
\end{tabularx}
\end{table}

\end{document}
